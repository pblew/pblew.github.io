{"version":3,"sources":["webpack://lib_web_settlers/./src/widgets/mapPanel/MapPanel.m.css","webpack://lib_web_settlers/./src/widgets/mapPanel/fragment.glsl","webpack://lib_web_settlers/./src/processes/loadMap.ts","webpack://lib_web_settlers/./src/widgets/mapPanel/MapPanel.tsx","webpack://lib_web_settlers/./src/widgets/mapPanel/vertex.glsl"],"names":["module","exports"," _key","root","loadMap","Object","factory","async","path","payload","mapId","map","api","operations","loadMapProcess","process","MapPanel_factory","vdom","store","middleware_store","properties","__webpack_exports__","middleware","onGLReady","executor","get","id","classes","MapPanel_m","GLPanel","fragmentSource","vertexSource","data"],"mappings":";;;;;;;;2IACAA,EAAAC,QAAA,CAAkBC,QAAA,wBAAAC,KAAA,0ECDH,4DCKf,MAAMC,EAAUC,OAAAC,EAAA,EAAAD,CAAcE,OAASC,OAAMC,cACzC,MAAMC,MAAEA,GAAUD,EACZE,QAAYN,OAAAO,EAAA,EAAAP,CAAKK,GACvB,MAAO,CAACL,OAAAQ,EAAA,EAAAR,CAAQG,EAAK,cAAeG,MAG3BG,EAAiBT,OAAAU,EAAA,EAAAV,CAAc,UAAW,CAACD,iBCIxD,MAAMY,EAAUX,OAAAY,EAAA,EAAAZ,CAAO,CAAEa,MAAAC,EAAA,IAASC,aAEnBC,EAAA,QAAAL,EAAQ,UAAoBM,YAAYJ,MAAEA,GAAOE,WAAEA,IAC9D,MAAMV,MAAEA,EAAKa,UAAEA,GAAcH,KACvBI,SAAEA,EAAQC,IAAEA,EAAGjB,KAAEA,GAASU,EAC1BP,EAAMc,EAAIjB,EAAK,eACrB,OAAKG,GAAOA,EAAIe,IAAMhB,EAKlBL,OAAAY,EAAA,EADG,CACH,OAAKU,QAAS,CAACC,EAAA,OACXvB,OAAAY,EAAA,EAAAZ,CAACwB,EAAA,EAAO,CAACC,eF3BN,yYE2BsCC,aC3BtC,siBD2BkEC,KAAMrB,EAAKY,UAAWA,MAL/FC,EAASV,EAATU,CAAyB,CAAEd,UACpBL,OAAAY,EAAA,EAAAZ,CAAA,OAAKsB,QAAS,CAACC,EAAA,OAAS","file":"src/widgets/mapPanel/MapPanel.b77093d143bebe16c044.bundle.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\" _key\":\"web-settlers/MapPanel\",\"root\":\"MapPanel-m__root__2249f481p3l\"};","export default \"#version 300 es\\n\\nprecision mediump float;\\nprecision mediump int;\\n\\nflat in vec4 vColour;\\nin vec3 vNormal;\\nuniform vec3 reverseLightDirection;\\nout vec4 pixelColour;\\n\\nvoid main(void) {\\n    vec3 normal = normalize(vNormal);\\n    float light = dot(normal, reverseLightDirection);\\n    // return the provided pixel colour\\n    pixelColour = vColour;\\n    pixelColour.rgb *= light;\\n}\\n\"","import { createProcess } from \"@dojo/framework/stores/process\";\nimport { replace } from \"@dojo/framework/stores/state/operations\";\nimport { read } from \"../api/api\";\nimport { createCommand } from \"./factory\";\n\nconst loadMap = createCommand(async ({ path, payload }) => {\n    const { mapId } = payload;\n    const map = await read(mapId);\n    return [replace(path(\"currentMap\"), map)];\n});\n\nexport const loadMapProcess = createProcess(\"loadMap\", [loadMap]);\n","import fragmentSource from \"!!ts-shader-loader!./fragment.glsl\";\nimport vertexSource from \"!!ts-shader-loader!./vertex.glsl\";\nimport { create, tsx } from \"@dojo/framework/core/vdom\";\n\nimport GLPanel from \"../../dojo-gl/widgets/GLPanel\";\nimport store from \"../../middleware/store\";\nimport { loadMapProcess } from \"../../processes/loadMap\";\n\nimport * as css from \"./MapPanel.m.css\";\n\nexport interface MapPanelProperties {\n    mapId: string;\n    onGLReady: (glPanel: GLPanel, data?: object) => void;\n}\n\nconst factory = create({ store }).properties<MapPanelProperties>();\n\nexport default factory(function MapPanel({ middleware: { store }, properties }) {\n    const { mapId, onGLReady } = properties();\n    const { executor, get, path } = store;\n    const map = get(path(\"currentMap\"));\n    if (!map || map.id != mapId) {\n        executor(loadMapProcess)({ mapId });\n        return <div classes={[css.root]}>Loading...</div>;\n    }\n    return (\n        <div classes={[css.root]}>\n            <GLPanel fragmentSource={fragmentSource} vertexSource={vertexSource} data={map} onGLReady={onGLReady} />\n        </div>\n    );\n});\n","export default \"#version 300 es\\n\\nprecision mediump float;\\nprecision mediump int;\\n\\nin vec3 vertexPos;\\nin vec4 vertexColour;\\nin vec3 vertexNormal;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nflat out vec4 vColour;\\nout vec3 vNormal;\\n\\nvoid main(void) {\\n    // return the transformed and projected vertex value\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);\\n    // output the vertexColour in vColour\\n    vColour = vertexColour;\\n    // output the vertexNormal in vNormal\\n    vNormal = vertexNormal;\\n}\\n\""],"sourceRoot":""}